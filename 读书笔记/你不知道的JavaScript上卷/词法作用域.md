## 词法作用域

作用域共有两种主要的工作模型，第一种最为普遍且被大多数编程语言所采用的词法作用域，另一种叫做动态作用域

### 词法阶段

词法作用域就是定义在词法阶段的作用域，因此当词法分析器处理代码时会保持作用域不变（大部分情况）

无论函数在哪里被调用、被如何调用，他的词法作用域都只由它被声明时所处的位置决定

### 欺骗词法

js中有两个机制来实现，但并不是什么好主意，欺骗词法作用域会导致性能下降

#### eval

eval()函数可以接受一个字符串，并将其内容视为好像在书写时就存在于程序中这个位置的代码   
就是根据这个原理来修改词法作用域环境的

如果eval()中包含一个或者多个声明就会对其所处的词法作用域进行修改

在严格模式中，eval()有自己的词法作用域

#### with

先举个栗子

```javascript
function foo(obj) {
	with(obj) {
		a = 2;
	}
}

var o1 = {
	a: 3;
};

var o2 = {
	b: 4;
};

foo(o1);
console.log(o1.a);//2

foo(o2);
console.log(o2.a);//undefined
console.log(a);//2
```

可以看到最后`a`被泄漏到全局作用域了

with可以将一个对象处理为一个完全隔离的词法作用域，当我们将`o2`作为作用域时，其中并没有`a`标识符    
因此进行了正常的LHS查找，自动创建了一个全局变量

严格模式会完全禁止with

#### 性能

js引擎会在编译阶段进行数项性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量以及函数的定义位置    
才能在执行中快速找到标识符

最悲观的情况如果出现了eval()或者是with，所有的优化可能都是无意义的，因此最简单的做法就是完全不去优化

所有如果有了这两者代码运行起来会变得非常慢