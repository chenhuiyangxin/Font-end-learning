## 作用域是什么

### 编译原理

javascript是一门编译语言，但与传统编译语言不同，，它不是提前编译的，编译结果也不能在分布式系统中移植

传统编译语言的流程中，程序中一段代码在执行前会经历三个步骤，统称为**编译**

1. 分词/词法分析   
这个过程会分解出代码块，这些代码块被称为**词法单元**

2. 解析/语法解析   
这个过程将**词法单元流（数组）**转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，即**“抽象语法树”**

3. 代码生成   
将AST（抽象语法树）转换为可执行代码的过程被称为代码生成，简单来说，就是转化为一组**机器指令**

比起以上这些，javascript引擎要复杂许多，例如在语法分析和代码生成阶段有特定的步骤对运行性能进行优化

### 理解作用域

#### 演员表

以`var a = 2`为例，参与对它进行处理的演员有

* 引擎   
从头到尾负责整个*编译及执行*过程

* 编译器   
负责语法分析及代码生成等脏活累活

* 作用域   
负责收集并维护所有**声明的标识符（变量）**组成的一系列*查询*，并实施一整套非常严格的规则，确定当前执行的代码对这些标识符的**访问权限**

#### 对话

还是以`var a = 2`为例，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。我们将其分解，看演员们如何协同工作

编译器

1. 遇到`var a`，编译器会询问作用域在同一作用域集合中是否已经存在该名称的变量，如果有，编译器会忽略此声明，否则   
会要求作用域在当前作用域集合中声明一个新变量，并命名为`a`

2. 接着编译器会为引擎生成处理`a = 2`这个赋值操作运行时所需的代码。引擎会询问作用域当前作用域集合是否存在一个   
叫做`a`的变量，如果是，引擎会使用这个变量，否则会按照作用域链继续查找

如果引擎最终找到`a`变量，就会将2赋值给他，否则抛出一个异常   

总结就是变量的赋值操作会执行两个操作，首先编译器在当前作用域中声明一个变量（如果之前没有声明过），然后在运行   
时引擎在作用域中查找该变量，如果能找到就会对其赋值

#### 编译器有话说

在我们的例子中，在作用域的协作下，引擎会为变量`a`进行LHS查找，另一种查找类型叫做RHS，L与R代表左侧与右侧，即一个赋值操作的左侧和右侧   
如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是为了获取变量的值，就会使用RHS查询，举个栗子

```javascript
function foo(a) {
    console.log(a);//2
}
foo(2);
```

引擎首先为`foo`进行RHS查找，然后对`a`进行LHS查找，因为要把2赋值给形参`a`;接着对`console`进行RHS查找，最后再对`a`进行RHS查找

### 作用域嵌套

作用域是根据名称查找变量的一套规则

引擎查找变量会遍历作用域链，从当前执行的作用域开始查找变量，找不到继续向上一级查找，直至找到或者到达全局作用域还未找到都会停止

### 异常

当RHS遍历完作用域链找不到所需变量时，引擎会抛出ReferenceError异常

相比之下，LHS查找不到时，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎，前提是在非严格模式下
