# 异步I/O与事件驱动

## 1.为什么要异步I/O

Node本就是面向网络而设计，而现在Web应用已经不是单台服务器就能胜任的时代了，在跨网络结构下，并发已是现代编程中的标准配备了。   
具体可以从**用户体验**和**资源分配**两方面来说。

### 1.1 用户体验

浏览器中，JS是在单线程上执行，并且和UI渲染共用一个线程。因此如果JS用同步的方式去获取一个网络资源，那在资源返回之前UI渲染就停滞了，    
这对用户体验来说是灾难性的。如果采用异步的方式，JS执行以及UI渲染都可以继续响应用户操作，这样才是合理的。当然，后端快速响应资源，    
也是前端体验提升的关键

### 1.2 资源分配

计算机可将组件分为I/O设备和计算设备，假设现在有一组互不相关的任务需要完成，通常有两种解决方式

1.单线程串行依次执行
2.多线程并行完成

先说多线程，它的问题在于创建线程和执行期线程上下文切换开销比较大，如果这个开销小于并行执行，那可以选择多线程。    
但是多线程还面临锁、状态同步等更复杂的问题，虽然它能在多核CPU上有效提升CPU的利用率。

单线程比较符合程序员按顺序思考的逻辑，但是性能太差，任何一个任务都会阻塞后续任务，无法充分利用计算机性能

上述两种方案都有各自的致命缺点，因此Node给出了它的方案：利用单线程远离死锁、状态同步等问题；利用异步I/O远离阻塞。    
这是Node的重要特点，它是首个将异步I/O应用在应用层的平台。

同时Node为了弥补无法利用多核CPU的缺点，它提供了类似浏览器中Web Workers的子进程来高效利用计算机资源。

## 2.异步I/O与非阻塞I/O

异步I/O并非Node原创，比如操作系统早已实现。    
从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事，操作系统内核对于I/O只有两种方式：阻塞与非阻塞。

阻塞I/O顾名思义就是要等到内核层面完成所有操作调用才结束，造成CPU等待I/O浪费时间与性能，因此内核提供了非阻塞I/O

非阻塞I/O会立即返回一个调用状态，为了获取完成的数据，应用程序需要重复调用I/O操作去确认，这就是轮询了。    
轮询同样也会造成CPU资源浪费，虽然轮询技术不断演进，对于应用程序来说这仍然算是一种同步，因为它依旧花费了时间去等待，     
这期间CPU要么在遍历文件描述符的状态，要么在休眠等待事件的发生。

## node的异步I/O实现

事件循环、观察者、执行回调、I/O线程池实现了node的异步I/O

每执行一次事件循环的过程称为Tick。每次Tick，先看有没有事件，如有就取出来，看他有没有回调，有就执行回调，没有继续看有没有事件，直至事件被取光，退出Tick。
其中每次看有没有事件，是观察者提供的，它监控着I/O线程池，一触发事件就交给线程池

我们可以打个比方

饭店里面，厨师做完手头最后一道菜，就回去询问服务员（观察者）有没有客人点菜（I/O线程池），如果有就继续去做（取出事件，有回调就执行回调）
直到无人点菜，就下班。这就是一个事件循环了
