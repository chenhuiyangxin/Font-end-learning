# 异步I/O与事件驱动

## 1.为什么要异步I/O

Node本就是面向网络而设计，而现在Web应用已经不是单台服务器就能胜任的时代了，在跨网络结构下，并发已是现代编程中的标准配备了。   
具体可以从**用户体验**和**资源分配**两方面来说。

### 1.1 用户体验

浏览器中，JS是在单线程上执行，并且和UI渲染共用一个线程。因此如果JS用同步的方式去获取一个网络资源，那在资源返回之前UI渲染就停滞了，    
这对用户体验来说是灾难性的。如果采用异步的方式，JS执行以及UI渲染都可以继续响应用户操作，这样才是合理的。当然，后端快速响应资源，    
也是前端体验提升的关键

### 1.2 资源分配

计算机可将组件分为I/O设备和计算设备，假设现在有一组互不相关的任务需要完成，通常有两种解决方式

1.单线程串行依次执行
2.多线程并行完成

先说多线程，它的问题在于创建线程和执行期线程上下文切换开销比较大，如果这个开销小于并行执行，那可以选择多线程。    
但是多线程还面临锁、状态同步等更复杂的问题，虽然它能在多核CPU上有效提升CPU的利用率。

单线程比较符合程序员按顺序思考的逻辑，但是性能太差，任何一个任务都会阻塞后续任务，无法充分利用计算机性能

上述两种方案都有各自的致命缺点，因此Node给出了它的方案：利用单线程远离死锁、状态同步等问题；利用异步I/O远离阻塞。    
这是Node的重要特点，它是首个将异步I/O应用在应用层的平台。

同时Node为了弥补无法利用多核CPU的缺点，它提供了类似浏览器中Web Workers的子进程来高效利用计算机资源。

## 2.异步I/O与非阻塞I/O

异步I/O并非Node原创，比如操作系统早已实现。    
从计算机内核I/O而言，异步/同步和阻塞/非阻塞实际上是两回事，操作系统内核对于I/O只有两种方式：阻塞与非阻塞。

阻塞I/O顾名思义就是要等到内核层面完成所有操作调用才结束，造成CPU等待I/O浪费时间与性能，因此内核提供了非阻塞I/O

非阻塞I/O会立即返回一个调用状态，为了获取完成的数据，应用程序需要重复调用I/O操作去确认，这就是轮询了。    
轮询同样也会造成CPU资源浪费，虽然轮询技术不断演进，对于应用程序来说这仍然算是一种同步，因为它依旧花费了时间去等待，     
这期间CPU要么在遍历文件描述符的状态，要么在休眠等待事件的发生。

### 2.1 现实的异步I/O

综上我们所期望的完美异步I/O并没有实现，所谓完美就是应用程序发起非阻塞调用，无须通过轮询直接处理下一个任务，I/O    
完成之后通过信号或者回调将数据传给应用程序即可。

那是不是没有这种完美的异步呢，答案是不是。前面所讲都是限定在单线程的情况下，如果是多线程则是另外一番景象。

通过让部分线程进行阻塞I/O或者非阻塞I/O，一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递。    
这样就轻松实现的异步I/O，虽然是模拟的。

\*nix平台下，Node自行实现了线程池完成异步I/O，Windows下的方案是IOCP，它们实现原理都是线程池原理。   
由于平台的差异，Node提供了libuv作为抽象封装层来兼容。

所以我们会发现平时常提到的Node是单线程的，这里的单线程仅仅指JavaScript运行在单线程中，内部完成I/O的另有线程池。

## 3.Node的异步I/O

以上我们捋清了阻塞I/O、非阻塞I/O、异步I/O的关系，下面就要详细的介绍Node是如何实现异步I/O的了。    
完成整个异步I/O需要**事件循环**、**观察者**和**请求对象**等环节。

### 3.1 事件循环

事件循环是Node自身的执行模型，正是它才使得回调函数十分普遍。

在启动进程时，Node会创建一个类似```while(true)```的循环，每执行一次循环体的过程我们称为**Tick**。    

每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数，如果存在关联回调就执行    
它们。然后进入下个循环。如果不再有事件处理，就退出进程

### 3.2 观察者

在每个Tick过程中，如何判断是否有事件需要处理呢，这就要靠观察者了。

每个事件循环都有一个或多个观察者，判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。

浏览器采用了类似的机制，事件可能来自用户的点击或者加载某些文件时产生，这些事件都有对应的观察者。     
在Node中，事件主要来自网路请求、文件I/O等。观察者将事件分了类。

事件循环是一个典型的*生产者/消费者*模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供    
不同类型的事件，这些事件被传递到观察者那里，事件循环则是从观察者那里取出事件并处理。

### 3.3 请求对象

我们通过解释Windows下异步I/O的简单例子来探寻从JavaScript代码到系统内核之间都发生了什么。

一般的回调函数都是由我们自行调用，比如

```javascript
  var forEach = function (list, callback) {
    for (var i = 0; i < list.length; i++) {
      callback(list[i], i, list);
    }
  };
```

而Node中的异步I/O调用中的回调函数却不是开发者调用的。那从我们发出调用到回调执行中间到底发生了什么呢？    
事实上，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它就是**请求对象**。

我们以最简单的```fs.open()```作为例子

```javascript
fs.open = function (path, flags, mode, callback) {
  //...
  binding.open(pathModule._makeLong(path),
                    stringToFlags(Flags),
                    mode,
                    callback
                    );
};
```

这儿JS层面的代码通过调用C++核心模块进行下层操作，最后实际上调用的是核心模块的```uv_fs_open()```方法。   
在此方法调用过程中，我们创建了一个```FSRepWrap```请求对象，从JS层传入的参数和当前方法都被封装在这个请求对象中。    
其中我们最为关注的回调函数则被设置在这个对象的```oncomplete_sym```属性上。

```
req_wrap->object_->Set(oncomplete_sym, callback);
```

对象包装完毕之后，在Windows下，则调用```QueueUserWorkItem()```方法将这个```FSRepWrap```对象推入线程池    
中等待执行。

```
QueueUserWorkItem(&uv_fs_thread_proc,
                                 req,
                                 WT_EXECUTEDEFAULT)
```

此方法接受三个参数，第一个是将要执行的方法的引用，第二个是将要执行方法运行时需要的参数，第三个参数是执行的标志。   
当线程池中有可用线程时，我们会调用```uv_fs_thread_proc（）```方法，它会根据传入参数的类型调用相应的底层函数。   
以```uv_fs_open()```为例，实际上调用```fs__open()```方法。

至此，JS调用立即返回，由JS层面发起的异步调用第一阶段就此结束，JS线程可以继续执行当前任务的后续操作。    
当前的I/O操作在线程池中等待执行，不管他是否阻塞I/O，都不会影响JS线程的后续操作，如此就达到了异步的目的。

请求对象是异步I/O过程中重要中间产物，所有状态都保存在这对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。

### 3.4 执行回调

以上操作是异步I/O第一部分，回调通知是第二部分。



