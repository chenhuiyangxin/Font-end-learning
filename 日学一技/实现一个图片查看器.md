# 实现一个图片查看器

## 原由

最近产品要实现一个图片查看器，类似微信或者今日头条查看图片的效果，支持一些手势缩放、下拉退出等功能。    
刚开始听到这个需求是懵逼的，脑子里大概只有些transform来实现缩放位移效果，于是开始了面向搜索引擎编程的旅程···     
这里就把学习的过程详细的讲一讲

## 需求

几个重要的需求点

1. 图片正常大小宽度固定为设备宽度，高度自适应；高度不超过设备高度的居中，超过设备高度后，图片顶部与设备顶部对齐，可上下滑动查看
2. 图片在原状态双击放大至两倍，从放大状态双击还原
3. 图片可用手势缩放，最大放大4倍，最小就是原状态
4. 当图片超过4倍或者小于1倍时，手势可继续缩放，但是松手后会还原至4倍或者1倍
5. 图片放大后可拖拽查看，拖拽边界为图片边界
6. 图片放大之后，如果高度还是没有超过设备高度，依然居中显示，并且上下不可拖拽
7. 单击可退出查看器
8. 下拉图片可退出查看器

其中最重要的就是如何实现缩放了，先来看看这部分如何实现

## 缩放

提到缩放，首先想到的就是transform的scale属性，以及拖动的时候要使用translate属性。当然还有一个matrix属性，可以同时解决缩放以及位移    
我们这儿因为要频繁的计算缩放、位移并且直接赋值给style，所以用matrix清晰一些，关于matrix可以看这篇文章 [matrix](https://juejin.im/entry/5b15ffa0e51d4506be266bac)

使用transform还有一个需要注意的点，就是变换基点，也就是`transform-origin`属性，默认值是`50% 50%`，也就是中点位置。

### 双指缩放

自从iPhone支持多点触控之后，到现在大部分手机都支持这个特性，通过不同的触控组合形成不同的手势，比如我们这儿需要的双指缩放    
通过触摸事件的`e.touches`可以知道触点的个数以及各自的位置坐标，计算双指手势产生的距离来计算出一个倍数应用到图片上

### 缩放倍数的计算

从双指手势产生的距离计算一个倍数，如何计算，这关乎到最终的用户体验。用touchmove时两个手指间的距离除以touchstart时的距离，得到一个倍数     

一开始的算法是用这个倍数加上图片目前的倍数，然后再减去1。我们设图片放大后的倍数为y，touchstart时的距离为10，     
touchmove移动的距离是x，最终得到这样一个函数   
`y=1+(n(n+1))/20`    
很显然这是一个二次函数，这导致的结果就是倍数变化的速度是随着移动距离的增加而增加的，具体到体验的话就是双指轻轻移动下，    
图片就会一下子变得很大，放大的速度与用户双指移动速度无关，只与移动距离有关，用户体验极差

经过一番对高中数学的复习之后，换了这样一个策略，我们还是设放大后倍数为y，touchmove移动的距离是x，图片原始宽度为100，      
我们直接把移动的距离增加到图片的宽度上去，然后计算倍数，可以得到这样一个函数   
`y=(100+x)/100`    
这样子就是一个线性函数了，用户移动速度不变，放大速度就不变，感觉上就顺滑很多

## 放大点的固定

当在双击放大或者双指放大的时候，我们希望放大结束后双击的那个点还在手指下，或者还在双指的中点位置。     
比方说，双击的点坐标是(x,y)，放大两倍之后坐标变成了(2x,2y)，但是触点还是(x,y)，那这个放大就不精确了    
如图1所示     
![](../static/img/swipe1.png)      
图1

图中红点为触点，坐标(1,1)，放大之后这个点就在(2,2)了，脱离了红点。

我们以高度不超过设备高度的图片为例，我们实现这个效果有两个方法    
1. 每次以触点或者双指中点为变换基点      
2. 基点不变，在进行倍数变化的同时进行位移

方法一，每次都以触点或者中点为基点的话，确实可以解决这个问题，但是每次缩放都要改变基点，最坑的是既然改变了基点，       
那么拖拽的时候就要以变化不停的基点来计算位移，这很麻烦。

方法二，基点不变，如图1中，放大之后想要(2,2)还处于红点，只要向下向左都位移1单位即可；    
也能保证每次拖拽位移的算法都是一样的

综上，我们还是采用第二种方法，有利于计算位移、计算最大位移方法复用。

### 实现精确放大

上面已经采用了第二种方式去实现精确放大，我们看下具体如何实现。   
如图2所示     
![](../static/img/swipe2.png)    

从触摸事件的事件对象拿到的X,Y坐标是相对于视口的，我们需要的是相对于图片的坐标。    
图片本身距离视口的顶部以及左边界分别是`offsetTop,offsetLeft`，假设红点距离图片左边界为`imgX`，距离顶部为`imgY`，那么      

`imgX=e.touches[0].pageX-offsetLeft ; imgY=e.touches[0].pageY-offsetTop`     

变换基点是中点，那么红点相对于中点的位移就能算了，假设X轴位移为`midX`，Y轴位移是`midY`，图片宽高分别是`imgWidth,imgHeight`，那么

`midX=imgX-(imgWidth/2) ; midY=imgY-(imgHeight/2)`

假设放大倍数是`scale`，那么放大之后红点相对于中点的位移就是`scale*midX ; scale*midY`     
要实现精确放大，就是要把放大之后的红点还移动到放大之前的红点位置，假设X轴位移是`moveX`，Y轴位移为`moveY`，那么 

`moveX=midX+(-midX)*scale ; moveY=midY+(-midY)*scale`

最终我们只要把样式 `transform:matrix(scale,0,0,scale,moveX,moveY)` 应用上，就能实现精确放大了。

**注意** ：第六个需求点

> 图片放大之后，如果高度还是没有超过设备高度，依然居中显示，并且上下不可拖拽

这儿要注意如果此时放大之后高度仍然不满足大于设备高度，那么matrix的最后一个值`moveY`不能应用，只能为0     
这样会造成放大点的上下错位，但是在预料之内。

## 拖拽的边界

放大之后的图片能够拖拽，超出视口范围的部分最多拖拽至与视口边界对齐    
如图3所示     
![](../static/img/swipe3.png)    

显而易见，放大之后，图片最多往右移动`dragX`的距离，那么X轴的位移值的绝对值不大于`dragX`即可。     
`dragX`为放大之后的图片宽度减去原宽度再除以二。    
高度上，放大后高度不大于设备高度不能位移，大于之后跟X轴同样处理即可。

## 超长图片

对于当宽度为设备宽度时，高度就超过设备高度的图片，需要顶部对齐，并且可以滑动查看。    
对齐方式用的flex布局，正常图片设置水平垂直居中即可，超长图片单独给这个单元设置`align-self:flex-start`即可

需要注意的是，由于这种图片在没有变化的时候就能上下滑动，在计算位移的时候要把`scrollTop`考虑进去

## 触摸事件

这也是个需要注意的点，因为交互比较复杂，我们需要区分左右滑动切换图片、双击放大、单击退出查看器、放大状态可拖拽、下拉退出查看器等等。     

需要一个健壮的信号系统在事件中去完美的区分这些操作。

至此，一些难点就基本解决了，还有些下拉退出之类的比较简单就不再详说。
 